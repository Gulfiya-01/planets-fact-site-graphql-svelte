{
  "version": 3,
  "sources": ["../../graphql/version.mjs", "../../graphql/jsutils/isAsyncIterable.mjs", "../../graphql/execution/mapAsyncIterator.mjs", "../../graphql/execution/subscribe.mjs", "../../graphql/validation/rules/custom/NoDeprecatedCustomRule.mjs", "../../graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.mjs", "../../graphql/utilities/getIntrospectionQuery.mjs", "../../graphql/utilities/getOperationAST.mjs", "../../graphql/utilities/getOperationRootType.mjs", "../../graphql/utilities/introspectionFromSchema.mjs", "../../graphql/utilities/buildClientSchema.mjs", "../../graphql/utilities/extendSchema.mjs", "../../graphql/utilities/buildASTSchema.mjs", "../../graphql/utilities/lexicographicSortSchema.mjs", "../../graphql/utilities/printSchema.mjs", "../../graphql/utilities/concatAST.mjs", "../../graphql/utilities/separateOperations.mjs", "../../graphql/utilities/stripIgnoredCharacters.mjs", "../../graphql/utilities/assertValidName.mjs", "../../graphql/utilities/findBreakingChanges.mjs"],
  "sourcesContent": ["// Note: This file is autogenerated using \"resources/gen-version.js\" script and\n// automatically updated by \"npm version\" command.\n\n/**\n * A string containing the version of the GraphQL.js library\n */\nexport const version = '16.8.1';\n/**\n * An object containing the components of the GraphQL.js version string\n */\n\nexport const versionInfo = Object.freeze({\n  major: 16,\n  minor: 8,\n  patch: 1,\n  preReleaseTag: null,\n});\n", "/**\n * Returns true if the provided object implements the AsyncIterator protocol via\n * implementing a `Symbol.asyncIterator` method.\n */\nexport function isAsyncIterable(maybeAsyncIterable) {\n  return (\n    typeof (maybeAsyncIterable === null || maybeAsyncIterable === void 0\n      ? void 0\n      : maybeAsyncIterable[Symbol.asyncIterator]) === 'function'\n  );\n}\n", "/**\n * Given an AsyncIterable and a callback function, return an AsyncIterator\n * which produces values mapped via calling the callback function.\n */\nexport function mapAsyncIterator(iterable, callback) {\n  const iterator = iterable[Symbol.asyncIterator]();\n\n  async function mapResult(result) {\n    if (result.done) {\n      return result;\n    }\n\n    try {\n      return {\n        value: await callback(result.value),\n        done: false,\n      };\n    } catch (error) {\n      /* c8 ignore start */\n      // FIXME: add test case\n      if (typeof iterator.return === 'function') {\n        try {\n          await iterator.return();\n        } catch (_e) {\n          /* ignore error */\n        }\n      }\n\n      throw error;\n      /* c8 ignore stop */\n    }\n  }\n\n  return {\n    async next() {\n      return mapResult(await iterator.next());\n    },\n\n    async return() {\n      // If iterator.return() does not exist, then type R must be undefined.\n      return typeof iterator.return === 'function'\n        ? mapResult(await iterator.return())\n        : {\n            value: undefined,\n            done: true,\n          };\n    },\n\n    async throw(error) {\n      if (typeof iterator.throw === 'function') {\n        return mapResult(await iterator.throw(error));\n      }\n\n      throw error;\n    },\n\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n", "import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { isAsyncIterable } from '../jsutils/isAsyncIterable.mjs';\nimport { addPath, pathToArray } from '../jsutils/Path.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { locatedError } from '../error/locatedError.mjs';\nimport { collectFields } from './collectFields.mjs';\nimport {\n  assertValidExecutionArguments,\n  buildExecutionContext,\n  buildResolveInfo,\n  execute,\n  getFieldDef,\n} from './execute.mjs';\nimport { mapAsyncIterator } from './mapAsyncIterator.mjs';\nimport { getArgumentValues } from './values.mjs';\n/**\n * Implements the \"Subscribe\" algorithm described in the GraphQL specification.\n *\n * Returns a Promise which resolves to either an AsyncIterator (if successful)\n * or an ExecutionResult (error). The promise will be rejected if the schema or\n * other arguments to this function are invalid, or if the resolved event stream\n * is not an async iterable.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with\n * descriptive errors and no data will be returned.\n *\n * If the source stream could not be created due to faulty subscription\n * resolver logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to an AsyncIterator, which\n * yields a stream of ExecutionResults representing the response stream.\n *\n * Accepts either an object with named arguments, or individual arguments.\n */\n\nexport async function subscribe(args) {\n  // Temporary for v15 to v16 migration. Remove in v17\n  arguments.length < 2 ||\n    devAssert(\n      false,\n      'graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.',\n    );\n  const resultOrStream = await createSourceEventStream(args);\n\n  if (!isAsyncIterable(resultOrStream)) {\n    return resultOrStream;\n  } // For each payload yielded from a subscription, map it over the normal\n  // GraphQL `execute` function, with `payload` as the rootValue.\n  // This implements the \"MapSourceToResponseEvent\" algorithm described in\n  // the GraphQL specification. The `execute` function provides the\n  // \"ExecuteSubscriptionEvent\" algorithm, as it is nearly identical to the\n  // \"ExecuteQuery\" algorithm, for which `execute` is also used.\n\n  const mapSourceToResponse = (payload) =>\n    execute({ ...args, rootValue: payload }); // Map every source value to a ExecutionResult value as described above.\n\n  return mapAsyncIterator(resultOrStream, mapSourceToResponse);\n}\n\nfunction toNormalizedArgs(args) {\n  const firstArg = args[0];\n\n  if (firstArg && 'document' in firstArg) {\n    return firstArg;\n  }\n\n  return {\n    schema: firstArg,\n    // FIXME: when underlying TS bug fixed, see https://github.com/microsoft/TypeScript/issues/31613\n    document: args[1],\n    rootValue: args[2],\n    contextValue: args[3],\n    variableValues: args[4],\n    operationName: args[5],\n    subscribeFieldResolver: args[6],\n  };\n}\n/**\n * Implements the \"CreateSourceEventStream\" algorithm described in the\n * GraphQL specification, resolving the subscription source event stream.\n *\n * Returns a Promise which resolves to either an AsyncIterable (if successful)\n * or an ExecutionResult (error). The promise will be rejected if the schema or\n * other arguments to this function are invalid, or if the resolved event stream\n * is not an async iterable.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with\n * descriptive errors and no data will be returned.\n *\n * If the the source stream could not be created due to faulty subscription\n * resolver logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to the AsyncIterable for the\n * event stream returned by the resolver.\n *\n * A Source Event Stream represents a sequence of events, each of which triggers\n * a GraphQL execution for that event.\n *\n * This may be useful when hosting the stateful subscription service in a\n * different process or machine than the stateless GraphQL execution engine,\n * or otherwise separating these two steps. For more on this, see the\n * \"Supporting Subscriptions at Scale\" information in the GraphQL specification.\n */\n\nexport async function createSourceEventStream(...rawArgs) {\n  const args = toNormalizedArgs(rawArgs);\n  const { schema, document, variableValues } = args; // If arguments are missing or incorrectly typed, this is an internal\n  // developer mistake which should throw an early error.\n\n  assertValidExecutionArguments(schema, document, variableValues); // If a valid execution context cannot be created due to incorrect arguments,\n  // a \"Response\" with only errors is returned.\n\n  const exeContext = buildExecutionContext(args); // Return early errors if execution context failed.\n\n  if (!('schema' in exeContext)) {\n    return {\n      errors: exeContext,\n    };\n  }\n\n  try {\n    const eventStream = await executeSubscription(exeContext); // Assert field returned an event stream, otherwise yield an error.\n\n    if (!isAsyncIterable(eventStream)) {\n      throw new Error(\n        'Subscription field must return Async Iterable. ' +\n          `Received: ${inspect(eventStream)}.`,\n      );\n    }\n\n    return eventStream;\n  } catch (error) {\n    // If it GraphQLError, report it as an ExecutionResult, containing only errors and no data.\n    // Otherwise treat the error as a system-class error and re-throw it.\n    if (error instanceof GraphQLError) {\n      return {\n        errors: [error],\n      };\n    }\n\n    throw error;\n  }\n}\n\nasync function executeSubscription(exeContext) {\n  const { schema, fragments, operation, variableValues, rootValue } =\n    exeContext;\n  const rootType = schema.getSubscriptionType();\n\n  if (rootType == null) {\n    throw new GraphQLError(\n      'Schema is not configured to execute subscription operation.',\n      {\n        nodes: operation,\n      },\n    );\n  }\n\n  const rootFields = collectFields(\n    schema,\n    fragments,\n    variableValues,\n    rootType,\n    operation.selectionSet,\n  );\n  const [responseName, fieldNodes] = [...rootFields.entries()][0];\n  const fieldDef = getFieldDef(schema, rootType, fieldNodes[0]);\n\n  if (!fieldDef) {\n    const fieldName = fieldNodes[0].name.value;\n    throw new GraphQLError(\n      `The subscription field \"${fieldName}\" is not defined.`,\n      {\n        nodes: fieldNodes,\n      },\n    );\n  }\n\n  const path = addPath(undefined, responseName, rootType.name);\n  const info = buildResolveInfo(\n    exeContext,\n    fieldDef,\n    fieldNodes,\n    rootType,\n    path,\n  );\n\n  try {\n    var _fieldDef$subscribe;\n\n    // Implements the \"ResolveFieldEventStream\" algorithm from GraphQL specification.\n    // It differs from \"ResolveFieldValue\" due to providing a different `resolveFn`.\n    // Build a JS object of arguments from the field.arguments AST, using the\n    // variables scope to fulfill any variable references.\n    const args = getArgumentValues(fieldDef, fieldNodes[0], variableValues); // The resolve function's optional third argument is a context value that\n    // is provided to every resolve function within an execution. It is commonly\n    // used to represent an authenticated user, or request-specific caches.\n\n    const contextValue = exeContext.contextValue; // Call the `subscribe()` resolver or the default resolver to produce an\n    // AsyncIterable yielding raw payloads.\n\n    const resolveFn =\n      (_fieldDef$subscribe = fieldDef.subscribe) !== null &&\n      _fieldDef$subscribe !== void 0\n        ? _fieldDef$subscribe\n        : exeContext.subscribeFieldResolver;\n    const eventStream = await resolveFn(rootValue, args, contextValue, info);\n\n    if (eventStream instanceof Error) {\n      throw eventStream;\n    }\n\n    return eventStream;\n  } catch (error) {\n    throw locatedError(error, fieldNodes, pathToArray(path));\n  }\n}\n", "import { invariant } from '../../../jsutils/invariant.mjs';\nimport { GraphQLError } from '../../../error/GraphQLError.mjs';\nimport { getNamedType, isInputObjectType } from '../../../type/definition.mjs';\n\n/**\n * No deprecated\n *\n * A GraphQL document is only valid if all selected fields and all used enum values have not been\n * deprecated.\n *\n * Note: This rule is optional and is not part of the Validation section of the GraphQL\n * Specification. The main purpose of this rule is detection of deprecated usages and not\n * necessarily to forbid their use when querying a service.\n */\nexport function NoDeprecatedCustomRule(context) {\n  return {\n    Field(node) {\n      const fieldDef = context.getFieldDef();\n      const deprecationReason =\n        fieldDef === null || fieldDef === void 0\n          ? void 0\n          : fieldDef.deprecationReason;\n\n      if (fieldDef && deprecationReason != null) {\n        const parentType = context.getParentType();\n        parentType != null || invariant(false);\n        context.reportError(\n          new GraphQLError(\n            `The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    Argument(node) {\n      const argDef = context.getArgument();\n      const deprecationReason =\n        argDef === null || argDef === void 0\n          ? void 0\n          : argDef.deprecationReason;\n\n      if (argDef && deprecationReason != null) {\n        const directiveDef = context.getDirective();\n\n        if (directiveDef != null) {\n          context.reportError(\n            new GraphQLError(\n              `Directive \"@${directiveDef.name}\" argument \"${argDef.name}\" is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        } else {\n          const parentType = context.getParentType();\n          const fieldDef = context.getFieldDef();\n          (parentType != null && fieldDef != null) || invariant(false);\n          context.reportError(\n            new GraphQLError(\n              `Field \"${parentType.name}.${fieldDef.name}\" argument \"${argDef.name}\" is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    ObjectField(node) {\n      const inputObjectDef = getNamedType(context.getParentInputType());\n\n      if (isInputObjectType(inputObjectDef)) {\n        const inputFieldDef = inputObjectDef.getFields()[node.name.value];\n        const deprecationReason =\n          inputFieldDef === null || inputFieldDef === void 0\n            ? void 0\n            : inputFieldDef.deprecationReason;\n\n        if (deprecationReason != null) {\n          context.reportError(\n            new GraphQLError(\n              `The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    EnumValue(node) {\n      const enumValueDef = context.getEnumValue();\n      const deprecationReason =\n        enumValueDef === null || enumValueDef === void 0\n          ? void 0\n          : enumValueDef.deprecationReason;\n\n      if (enumValueDef && deprecationReason != null) {\n        const enumTypeDef = getNamedType(context.getInputType());\n        enumTypeDef != null || invariant(false);\n        context.reportError(\n          new GraphQLError(\n            `The enum value \"${enumTypeDef.name}.${enumValueDef.name}\" is deprecated. ${deprecationReason}`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n", "import { GraphQLError } from '../../../error/GraphQLError.mjs';\nimport { getNamedType } from '../../../type/definition.mjs';\nimport { isIntrospectionType } from '../../../type/introspection.mjs';\n\n/**\n * Prohibit introspection queries\n *\n * A GraphQL document is only valid if all fields selected are not fields that\n * return an introspection type.\n *\n * Note: This rule is optional and is not part of the Validation section of the\n * GraphQL Specification. This rule effectively disables introspection, which\n * does not reflect best practices and should only be done if absolutely necessary.\n */\nexport function NoSchemaIntrospectionCustomRule(context) {\n  return {\n    Field(node) {\n      const type = getNamedType(context.getType());\n\n      if (type && isIntrospectionType(type)) {\n        context.reportError(\n          new GraphQLError(\n            `GraphQL introspection has been disabled, but the requested query contained the field \"${node.name.value}\".`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n", "/**\n * Produce the GraphQL query recommended for a full schema introspection.\n * Accepts optional IntrospectionOptions.\n */\nexport function getIntrospectionQuery(options) {\n  const optionsWithDefault = {\n    descriptions: true,\n    specifiedByUrl: false,\n    directiveIsRepeatable: false,\n    schemaDescription: false,\n    inputValueDeprecation: false,\n    ...options,\n  };\n  const descriptions = optionsWithDefault.descriptions ? 'description' : '';\n  const specifiedByUrl = optionsWithDefault.specifiedByUrl\n    ? 'specifiedByURL'\n    : '';\n  const directiveIsRepeatable = optionsWithDefault.directiveIsRepeatable\n    ? 'isRepeatable'\n    : '';\n  const schemaDescription = optionsWithDefault.schemaDescription\n    ? descriptions\n    : '';\n\n  function inputDeprecation(str) {\n    return optionsWithDefault.inputValueDeprecation ? str : '';\n  }\n\n  return `\n    query IntrospectionQuery {\n      __schema {\n        ${schemaDescription}\n        queryType { name }\n        mutationType { name }\n        subscriptionType { name }\n        types {\n          ...FullType\n        }\n        directives {\n          name\n          ${descriptions}\n          ${directiveIsRepeatable}\n          locations\n          args${inputDeprecation('(includeDeprecated: true)')} {\n            ...InputValue\n          }\n        }\n      }\n    }\n\n    fragment FullType on __Type {\n      kind\n      name\n      ${descriptions}\n      ${specifiedByUrl}\n      fields(includeDeprecated: true) {\n        name\n        ${descriptions}\n        args${inputDeprecation('(includeDeprecated: true)')} {\n          ...InputValue\n        }\n        type {\n          ...TypeRef\n        }\n        isDeprecated\n        deprecationReason\n      }\n      inputFields${inputDeprecation('(includeDeprecated: true)')} {\n        ...InputValue\n      }\n      interfaces {\n        ...TypeRef\n      }\n      enumValues(includeDeprecated: true) {\n        name\n        ${descriptions}\n        isDeprecated\n        deprecationReason\n      }\n      possibleTypes {\n        ...TypeRef\n      }\n    }\n\n    fragment InputValue on __InputValue {\n      name\n      ${descriptions}\n      type { ...TypeRef }\n      defaultValue\n      ${inputDeprecation('isDeprecated')}\n      ${inputDeprecation('deprecationReason')}\n    }\n\n    fragment TypeRef on __Type {\n      kind\n      name\n      ofType {\n        kind\n        name\n        ofType {\n          kind\n          name\n          ofType {\n            kind\n            name\n            ofType {\n              kind\n              name\n              ofType {\n                kind\n                name\n                ofType {\n                  kind\n                  name\n                  ofType {\n                    kind\n                    name\n                    ofType {\n                      kind\n                      name\n                      ofType {\n                        kind\n                        name\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  `;\n}\n", "import { Kind } from '../language/kinds.mjs';\n/**\n * Returns an operation AST given a document AST and optionally an operation\n * name. If a name is not provided, an operation is only returned if only one is\n * provided in the document.\n */\n\nexport function getOperationAST(documentAST, operationName) {\n  let operation = null;\n\n  for (const definition of documentAST.definitions) {\n    if (definition.kind === Kind.OPERATION_DEFINITION) {\n      var _definition$name;\n\n      if (operationName == null) {\n        // If no operation name was provided, only return an Operation if there\n        // is one defined in the document. Upon encountering the second, return\n        // null.\n        if (operation) {\n          return null;\n        }\n\n        operation = definition;\n      } else if (\n        ((_definition$name = definition.name) === null ||\n        _definition$name === void 0\n          ? void 0\n          : _definition$name.value) === operationName\n      ) {\n        return definition;\n      }\n    }\n  }\n\n  return operation;\n}\n", "import { GraphQLError } from '../error/GraphQLError.mjs';\n\n/**\n * Extracts the root type of the operation from the schema.\n *\n * @deprecated Please use `GraphQLSchema.getRootType` instead. Will be removed in v17\n */\nexport function getOperationRootType(schema, operation) {\n  if (operation.operation === 'query') {\n    const queryType = schema.getQueryType();\n\n    if (!queryType) {\n      throw new GraphQLError(\n        'Schema does not define the required query root type.',\n        {\n          nodes: operation,\n        },\n      );\n    }\n\n    return queryType;\n  }\n\n  if (operation.operation === 'mutation') {\n    const mutationType = schema.getMutationType();\n\n    if (!mutationType) {\n      throw new GraphQLError('Schema is not configured for mutations.', {\n        nodes: operation,\n      });\n    }\n\n    return mutationType;\n  }\n\n  if (operation.operation === 'subscription') {\n    const subscriptionType = schema.getSubscriptionType();\n\n    if (!subscriptionType) {\n      throw new GraphQLError('Schema is not configured for subscriptions.', {\n        nodes: operation,\n      });\n    }\n\n    return subscriptionType;\n  }\n\n  throw new GraphQLError(\n    'Can only have query, mutation and subscription operations.',\n    {\n      nodes: operation,\n    },\n  );\n}\n", "import { invariant } from '../jsutils/invariant.mjs';\nimport { parse } from '../language/parser.mjs';\nimport { executeSync } from '../execution/execute.mjs';\nimport { getIntrospectionQuery } from './getIntrospectionQuery.mjs';\n/**\n * Build an IntrospectionQuery from a GraphQLSchema\n *\n * IntrospectionQuery is useful for utilities that care about type and field\n * relationships, but do not need to traverse through those relationships.\n *\n * This is the inverse of buildClientSchema. The primary use case is outside\n * of the server context, for instance when doing schema comparisons.\n */\n\nexport function introspectionFromSchema(schema, options) {\n  const optionsWithDefaults = {\n    specifiedByUrl: true,\n    directiveIsRepeatable: true,\n    schemaDescription: true,\n    inputValueDeprecation: true,\n    ...options,\n  };\n  const document = parse(getIntrospectionQuery(optionsWithDefaults));\n  const result = executeSync({\n    schema,\n    document,\n  });\n  (!result.errors && result.data) || invariant(false);\n  return result.data;\n}\n", "import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { keyValMap } from '../jsutils/keyValMap.mjs';\nimport { parseValue } from '../language/parser.mjs';\nimport {\n  assertInterfaceType,\n  assertNullableType,\n  assertObjectType,\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLScalarType,\n  GraphQLUnionType,\n  isInputType,\n  isOutputType,\n} from '../type/definition.mjs';\nimport { GraphQLDirective } from '../type/directives.mjs';\nimport { introspectionTypes, TypeKind } from '../type/introspection.mjs';\nimport { specifiedScalarTypes } from '../type/scalars.mjs';\nimport { GraphQLSchema } from '../type/schema.mjs';\nimport { valueFromAST } from './valueFromAST.mjs';\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\n\nexport function buildClientSchema(introspection, options) {\n  (isObjectLike(introspection) && isObjectLike(introspection.__schema)) ||\n    devAssert(\n      false,\n      `Invalid or incomplete introspection result. Ensure that you are passing \"data\" property of introspection response and no \"errors\" was returned alongside: ${inspect(\n        introspection,\n      )}.`,\n    ); // Get the schema from the introspection result.\n\n  const schemaIntrospection = introspection.__schema; // Iterate through all types, getting the type definition for each.\n\n  const typeMap = keyValMap(\n    schemaIntrospection.types,\n    (typeIntrospection) => typeIntrospection.name,\n    (typeIntrospection) => buildType(typeIntrospection),\n  ); // Include standard types only if they are used.\n\n  for (const stdType of [...specifiedScalarTypes, ...introspectionTypes]) {\n    if (typeMap[stdType.name]) {\n      typeMap[stdType.name] = stdType;\n    }\n  } // Get the root Query, Mutation, and Subscription types.\n\n  const queryType = schemaIntrospection.queryType\n    ? getObjectType(schemaIntrospection.queryType)\n    : null;\n  const mutationType = schemaIntrospection.mutationType\n    ? getObjectType(schemaIntrospection.mutationType)\n    : null;\n  const subscriptionType = schemaIntrospection.subscriptionType\n    ? getObjectType(schemaIntrospection.subscriptionType)\n    : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  const directives = schemaIntrospection.directives\n    ? schemaIntrospection.directives.map(buildDirective)\n    : []; // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    description: schemaIntrospection.description,\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: Object.values(typeMap),\n    directives,\n    assumeValid:\n      options === null || options === void 0 ? void 0 : options.assumeValid,\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === TypeKind.LIST) {\n      const itemRef = typeRef.ofType;\n\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      return new GraphQLList(getType(itemRef));\n    }\n\n    if (typeRef.kind === TypeKind.NON_NULL) {\n      const nullableRef = typeRef.ofType;\n\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      const nullableType = getType(nullableRef);\n      return new GraphQLNonNull(assertNullableType(nullableType));\n    }\n\n    return getNamedType(typeRef);\n  }\n\n  function getNamedType(typeRef) {\n    const typeName = typeRef.name;\n\n    if (!typeName) {\n      throw new Error(`Unknown type reference: ${inspect(typeRef)}.`);\n    }\n\n    const type = typeMap[typeName];\n\n    if (!type) {\n      throw new Error(\n        `Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`,\n      );\n    }\n\n    return type;\n  }\n\n  function getObjectType(typeRef) {\n    return assertObjectType(getNamedType(typeRef));\n  }\n\n  function getInterfaceType(typeRef) {\n    return assertInterfaceType(getNamedType(typeRef));\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n  function buildType(type) {\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (type != null && type.name != null && type.kind != null) {\n      // FIXME: Properly type IntrospectionType, it's a breaking change so fix in v17\n      // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n      switch (type.kind) {\n        case TypeKind.SCALAR:\n          return buildScalarDef(type);\n\n        case TypeKind.OBJECT:\n          return buildObjectDef(type);\n\n        case TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n\n        case TypeKind.UNION:\n          return buildUnionDef(type);\n\n        case TypeKind.ENUM:\n          return buildEnumDef(type);\n\n        case TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n\n    const typeStr = inspect(type);\n    throw new Error(\n      `Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`,\n    );\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      specifiedByURL: scalarIntrospection.specifiedByURL,\n    });\n  }\n\n  function buildImplementationsList(implementingIntrospection) {\n    // TODO: Temporary workaround until GraphQL ecosystem will fully support\n    // 'interfaces' on interface types.\n    if (\n      implementingIntrospection.interfaces === null &&\n      implementingIntrospection.kind === TypeKind.INTERFACE\n    ) {\n      return [];\n    }\n\n    if (!implementingIntrospection.interfaces) {\n      const implementingIntrospectionStr = inspect(implementingIntrospection);\n      throw new Error(\n        `Introspection result missing interfaces: ${implementingIntrospectionStr}.`,\n      );\n    }\n\n    return implementingIntrospection.interfaces.map(getInterfaceType);\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    return new GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: () => buildImplementationsList(objectIntrospection),\n      fields: () => buildFieldDefMap(objectIntrospection),\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      interfaces: () => buildImplementationsList(interfaceIntrospection),\n      fields: () => buildFieldDefMap(interfaceIntrospection),\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      const unionIntrospectionStr = inspect(unionIntrospection);\n      throw new Error(\n        `Introspection result missing possibleTypes: ${unionIntrospectionStr}.`,\n      );\n    }\n\n    return new GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: () => unionIntrospection.possibleTypes.map(getObjectType),\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      const enumIntrospectionStr = inspect(enumIntrospection);\n      throw new Error(\n        `Introspection result missing enumValues: ${enumIntrospectionStr}.`,\n      );\n    }\n\n    return new GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: keyValMap(\n        enumIntrospection.enumValues,\n        (valueIntrospection) => valueIntrospection.name,\n        (valueIntrospection) => ({\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason,\n        }),\n      ),\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      const inputObjectIntrospectionStr = inspect(inputObjectIntrospection);\n      throw new Error(\n        `Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`,\n      );\n    }\n\n    return new GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields),\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error(\n        `Introspection result missing fields: ${inspect(typeIntrospection)}.`,\n      );\n    }\n\n    return keyValMap(\n      typeIntrospection.fields,\n      (fieldIntrospection) => fieldIntrospection.name,\n      buildField,\n    );\n  }\n\n  function buildField(fieldIntrospection) {\n    const type = getType(fieldIntrospection.type);\n\n    if (!isOutputType(type)) {\n      const typeStr = inspect(type);\n      throw new Error(\n        `Introspection must provide output type for fields, but received: ${typeStr}.`,\n      );\n    }\n\n    if (!fieldIntrospection.args) {\n      const fieldIntrospectionStr = inspect(fieldIntrospection);\n      throw new Error(\n        `Introspection result missing field args: ${fieldIntrospectionStr}.`,\n      );\n    }\n\n    return {\n      description: fieldIntrospection.description,\n      deprecationReason: fieldIntrospection.deprecationReason,\n      type,\n      args: buildInputValueDefMap(fieldIntrospection.args),\n    };\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return keyValMap(\n      inputValueIntrospections,\n      (inputValue) => inputValue.name,\n      buildInputValue,\n    );\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    const type = getType(inputValueIntrospection.type);\n\n    if (!isInputType(type)) {\n      const typeStr = inspect(type);\n      throw new Error(\n        `Introspection must provide input type for arguments, but received: ${typeStr}.`,\n      );\n    }\n\n    const defaultValue =\n      inputValueIntrospection.defaultValue != null\n        ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type)\n        : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type,\n      defaultValue,\n      deprecationReason: inputValueIntrospection.deprecationReason,\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      const directiveIntrospectionStr = inspect(directiveIntrospection);\n      throw new Error(\n        `Introspection result missing directive args: ${directiveIntrospectionStr}.`,\n      );\n    }\n\n    if (!directiveIntrospection.locations) {\n      const directiveIntrospectionStr = inspect(directiveIntrospection);\n      throw new Error(\n        `Introspection result missing directive locations: ${directiveIntrospectionStr}.`,\n      );\n    }\n\n    return new GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      isRepeatable: directiveIntrospection.isRepeatable,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args),\n    });\n  }\n}\n", "import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { keyMap } from '../jsutils/keyMap.mjs';\nimport { mapValue } from '../jsutils/mapValue.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport {\n  isTypeDefinitionNode,\n  isTypeExtensionNode,\n} from '../language/predicates.mjs';\nimport {\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLScalarType,\n  GraphQLUnionType,\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n} from '../type/definition.mjs';\nimport {\n  GraphQLDeprecatedDirective,\n  GraphQLDirective,\n  GraphQLSpecifiedByDirective,\n} from '../type/directives.mjs';\nimport {\n  introspectionTypes,\n  isIntrospectionType,\n} from '../type/introspection.mjs';\nimport {\n  isSpecifiedScalarType,\n  specifiedScalarTypes,\n} from '../type/scalars.mjs';\nimport { assertSchema, GraphQLSchema } from '../type/schema.mjs';\nimport { assertValidSDLExtension } from '../validation/validate.mjs';\nimport { getDirectiveValues } from '../execution/values.mjs';\nimport { valueFromAST } from './valueFromAST.mjs';\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n */\nexport function extendSchema(schema, documentAST, options) {\n  assertSchema(schema);\n  (documentAST != null && documentAST.kind === Kind.DOCUMENT) ||\n    devAssert(false, 'Must provide valid Document AST.');\n\n  if (\n    (options === null || options === void 0 ? void 0 : options.assumeValid) !==\n      true &&\n    (options === null || options === void 0\n      ? void 0\n      : options.assumeValidSDL) !== true\n  ) {\n    assertValidSDLExtension(documentAST, schema);\n  }\n\n  const schemaConfig = schema.toConfig();\n  const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);\n  return schemaConfig === extendedConfig\n    ? schema\n    : new GraphQLSchema(extendedConfig);\n}\n/**\n * @internal\n */\n\nexport function extendSchemaImpl(schemaConfig, documentAST, options) {\n  var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;\n\n  // Collect the type definitions and extensions found in the document.\n  const typeDefs = [];\n  const typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  const directiveDefs = [];\n  let schemaDef; // Schema extensions are collected which may add additional operation types.\n\n  const schemaExtensions = [];\n\n  for (const def of documentAST.definitions) {\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (def.kind === Kind.SCHEMA_EXTENSION) {\n      schemaExtensions.push(def);\n    } else if (isTypeDefinitionNode(def)) {\n      typeDefs.push(def);\n    } else if (isTypeExtensionNode(def)) {\n      const extendedTypeName = def.name.value;\n      const existingTypeExtensions = typeExtensionsMap[extendedTypeName];\n      typeExtensionsMap[extendedTypeName] = existingTypeExtensions\n        ? existingTypeExtensions.concat([def])\n        : [def];\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n  if (\n    Object.keys(typeExtensionsMap).length === 0 &&\n    typeDefs.length === 0 &&\n    directiveDefs.length === 0 &&\n    schemaExtensions.length === 0 &&\n    schemaDef == null\n  ) {\n    return schemaConfig;\n  }\n\n  const typeMap = Object.create(null);\n\n  for (const existingType of schemaConfig.types) {\n    typeMap[existingType.name] = extendNamedType(existingType);\n  }\n\n  for (const typeNode of typeDefs) {\n    var _stdTypeMap$name;\n\n    const name = typeNode.name.value;\n    typeMap[name] =\n      (_stdTypeMap$name = stdTypeMap[name]) !== null &&\n      _stdTypeMap$name !== void 0\n        ? _stdTypeMap$name\n        : buildType(typeNode);\n  }\n\n  const operationTypes = {\n    // Get the extended root operation types.\n    query: schemaConfig.query && replaceNamedType(schemaConfig.query),\n    mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),\n    subscription:\n      schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),\n    // Then, incorporate schema definition and all schema extensions.\n    ...(schemaDef && getOperationTypes([schemaDef])),\n    ...getOperationTypes(schemaExtensions),\n  }; // Then produce and return a Schema config with these types.\n\n  return {\n    description:\n      (_schemaDef = schemaDef) === null || _schemaDef === void 0\n        ? void 0\n        : (_schemaDef$descriptio = _schemaDef.description) === null ||\n          _schemaDef$descriptio === void 0\n        ? void 0\n        : _schemaDef$descriptio.value,\n    ...operationTypes,\n    types: Object.values(typeMap),\n    directives: [\n      ...schemaConfig.directives.map(replaceDirective),\n      ...directiveDefs.map(buildDirective),\n    ],\n    extensions: Object.create(null),\n    astNode:\n      (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0\n        ? _schemaDef2\n        : schemaConfig.astNode,\n    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),\n    assumeValid:\n      (_options$assumeValid =\n        options === null || options === void 0\n          ? void 0\n          : options.assumeValid) !== null && _options$assumeValid !== void 0\n        ? _options$assumeValid\n        : false,\n  }; // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function replaceType(type) {\n    if (isListType(type)) {\n      // @ts-expect-error\n      return new GraphQLList(replaceType(type.ofType));\n    }\n\n    if (isNonNullType(type)) {\n      // @ts-expect-error\n      return new GraphQLNonNull(replaceType(type.ofType));\n    } // @ts-expect-error FIXME\n\n    return replaceNamedType(type);\n  }\n\n  function replaceNamedType(type) {\n    // Note: While this could make early assertions to get the correctly\n    // typed values, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    return typeMap[type.name];\n  }\n\n  function replaceDirective(directive) {\n    const config = directive.toConfig();\n    return new GraphQLDirective({\n      ...config,\n      args: mapValue(config.args, extendArg),\n    });\n  }\n\n  function extendNamedType(type) {\n    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {\n      // Builtin types are not extended.\n      return type;\n    }\n\n    if (isScalarType(type)) {\n      return extendScalarType(type);\n    }\n\n    if (isObjectType(type)) {\n      return extendObjectType(type);\n    }\n\n    if (isInterfaceType(type)) {\n      return extendInterfaceType(type);\n    }\n\n    if (isUnionType(type)) {\n      return extendUnionType(type);\n    }\n\n    if (isEnumType(type)) {\n      return extendEnumType(type);\n    }\n\n    if (isInputObjectType(type)) {\n      return extendInputObjectType(type);\n    }\n    /* c8 ignore next 3 */\n    // Not reachable, all possible type definition nodes have been considered.\n\n    false || invariant(false, 'Unexpected type: ' + inspect(type));\n  }\n\n  function extendInputObjectType(type) {\n    var _typeExtensionsMap$co;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co !== void 0\n        ? _typeExtensionsMap$co\n        : [];\n    return new GraphQLInputObjectType({\n      ...config,\n      fields: () => ({\n        ...mapValue(config.fields, (field) => ({\n          ...field,\n          type: replaceType(field.type),\n        })),\n        ...buildInputFieldMap(extensions),\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendEnumType(type) {\n    var _typeExtensionsMap$ty;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null &&\n      _typeExtensionsMap$ty !== void 0\n        ? _typeExtensionsMap$ty\n        : [];\n    return new GraphQLEnumType({\n      ...config,\n      values: { ...config.values, ...buildEnumValueMap(extensions) },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendScalarType(type) {\n    var _typeExtensionsMap$co2;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co2 !== void 0\n        ? _typeExtensionsMap$co2\n        : [];\n    let specifiedByURL = config.specifiedByURL;\n\n    for (const extensionNode of extensions) {\n      var _getSpecifiedByURL;\n\n      specifiedByURL =\n        (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null &&\n        _getSpecifiedByURL !== void 0\n          ? _getSpecifiedByURL\n          : specifiedByURL;\n    }\n\n    return new GraphQLScalarType({\n      ...config,\n      specifiedByURL,\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendObjectType(type) {\n    var _typeExtensionsMap$co3;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co3 !== void 0\n        ? _typeExtensionsMap$co3\n        : [];\n    return new GraphQLObjectType({\n      ...config,\n      interfaces: () => [\n        ...type.getInterfaces().map(replaceNamedType),\n        ...buildInterfaces(extensions),\n      ],\n      fields: () => ({\n        ...mapValue(config.fields, extendField),\n        ...buildFieldMap(extensions),\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendInterfaceType(type) {\n    var _typeExtensionsMap$co4;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co4 !== void 0\n        ? _typeExtensionsMap$co4\n        : [];\n    return new GraphQLInterfaceType({\n      ...config,\n      interfaces: () => [\n        ...type.getInterfaces().map(replaceNamedType),\n        ...buildInterfaces(extensions),\n      ],\n      fields: () => ({\n        ...mapValue(config.fields, extendField),\n        ...buildFieldMap(extensions),\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendUnionType(type) {\n    var _typeExtensionsMap$co5;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co5 !== void 0\n        ? _typeExtensionsMap$co5\n        : [];\n    return new GraphQLUnionType({\n      ...config,\n      types: () => [\n        ...type.getTypes().map(replaceNamedType),\n        ...buildUnionTypes(extensions),\n      ],\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendField(field) {\n    return {\n      ...field,\n      type: replaceType(field.type),\n      args: field.args && mapValue(field.args, extendArg),\n    };\n  }\n\n  function extendArg(arg) {\n    return { ...arg, type: replaceType(arg.type) };\n  }\n\n  function getOperationTypes(nodes) {\n    const opTypes = {};\n\n    for (const node of nodes) {\n      var _node$operationTypes;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      const operationTypesNodes =\n        /* c8 ignore next */\n        (_node$operationTypes = node.operationTypes) !== null &&\n        _node$operationTypes !== void 0\n          ? _node$operationTypes\n          : [];\n\n      for (const operationType of operationTypesNodes) {\n        // Note: While this could make early assertions to get the correctly\n        // typed values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n        // @ts-expect-error\n        opTypes[operationType.operation] = getNamedType(operationType.type);\n      }\n    }\n\n    return opTypes;\n  }\n\n  function getNamedType(node) {\n    var _stdTypeMap$name2;\n\n    const name = node.name.value;\n    const type =\n      (_stdTypeMap$name2 = stdTypeMap[name]) !== null &&\n      _stdTypeMap$name2 !== void 0\n        ? _stdTypeMap$name2\n        : typeMap[name];\n\n    if (type === undefined) {\n      throw new Error(`Unknown type: \"${name}\".`);\n    }\n\n    return type;\n  }\n\n  function getWrappedType(node) {\n    if (node.kind === Kind.LIST_TYPE) {\n      return new GraphQLList(getWrappedType(node.type));\n    }\n\n    if (node.kind === Kind.NON_NULL_TYPE) {\n      return new GraphQLNonNull(getWrappedType(node.type));\n    }\n\n    return getNamedType(node);\n  }\n\n  function buildDirective(node) {\n    var _node$description;\n\n    return new GraphQLDirective({\n      name: node.name.value,\n      description:\n        (_node$description = node.description) === null ||\n        _node$description === void 0\n          ? void 0\n          : _node$description.value,\n      // @ts-expect-error\n      locations: node.locations.map(({ value }) => value),\n      isRepeatable: node.repeatable,\n      args: buildArgumentMap(node.arguments),\n      astNode: node,\n    });\n  }\n\n  function buildFieldMap(nodes) {\n    const fieldConfigMap = Object.create(null);\n\n    for (const node of nodes) {\n      var _node$fields;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      const nodeFields =\n        /* c8 ignore next */\n        (_node$fields = node.fields) !== null && _node$fields !== void 0\n          ? _node$fields\n          : [];\n\n      for (const field of nodeFields) {\n        var _field$description;\n\n        fieldConfigMap[field.name.value] = {\n          // Note: While this could make assertions to get the correctly typed\n          // value, that would throw immediately while type system validation\n          // with validateSchema() will produce more actionable results.\n          type: getWrappedType(field.type),\n          description:\n            (_field$description = field.description) === null ||\n            _field$description === void 0\n              ? void 0\n              : _field$description.value,\n          args: buildArgumentMap(field.arguments),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field,\n        };\n      }\n    }\n\n    return fieldConfigMap;\n  }\n\n  function buildArgumentMap(args) {\n    // FIXME: https://github.com/graphql/graphql-js/issues/2203\n    const argsNodes =\n      /* c8 ignore next */\n      args !== null && args !== void 0 ? args : [];\n    const argConfigMap = Object.create(null);\n\n    for (const arg of argsNodes) {\n      var _arg$description;\n\n      // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n      const type = getWrappedType(arg.type);\n      argConfigMap[arg.name.value] = {\n        type,\n        description:\n          (_arg$description = arg.description) === null ||\n          _arg$description === void 0\n            ? void 0\n            : _arg$description.value,\n        defaultValue: valueFromAST(arg.defaultValue, type),\n        deprecationReason: getDeprecationReason(arg),\n        astNode: arg,\n      };\n    }\n\n    return argConfigMap;\n  }\n\n  function buildInputFieldMap(nodes) {\n    const inputFieldMap = Object.create(null);\n\n    for (const node of nodes) {\n      var _node$fields2;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      const fieldsNodes =\n        /* c8 ignore next */\n        (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0\n          ? _node$fields2\n          : [];\n\n      for (const field of fieldsNodes) {\n        var _field$description2;\n\n        // Note: While this could make assertions to get the correctly typed\n        // value, that would throw immediately while type system validation\n        // with validateSchema() will produce more actionable results.\n        const type = getWrappedType(field.type);\n        inputFieldMap[field.name.value] = {\n          type,\n          description:\n            (_field$description2 = field.description) === null ||\n            _field$description2 === void 0\n              ? void 0\n              : _field$description2.value,\n          defaultValue: valueFromAST(field.defaultValue, type),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field,\n        };\n      }\n    }\n\n    return inputFieldMap;\n  }\n\n  function buildEnumValueMap(nodes) {\n    const enumValueMap = Object.create(null);\n\n    for (const node of nodes) {\n      var _node$values;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      const valuesNodes =\n        /* c8 ignore next */\n        (_node$values = node.values) !== null && _node$values !== void 0\n          ? _node$values\n          : [];\n\n      for (const value of valuesNodes) {\n        var _value$description;\n\n        enumValueMap[value.name.value] = {\n          description:\n            (_value$description = value.description) === null ||\n            _value$description === void 0\n              ? void 0\n              : _value$description.value,\n          deprecationReason: getDeprecationReason(value),\n          astNode: value,\n        };\n      }\n    }\n\n    return enumValueMap;\n  }\n\n  function buildInterfaces(nodes) {\n    // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    // @ts-expect-error\n    return nodes.flatMap(\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      (node) => {\n        var _node$interfaces$map, _node$interfaces;\n\n        return (\n          /* c8 ignore next */\n          (_node$interfaces$map =\n            (_node$interfaces = node.interfaces) === null ||\n            _node$interfaces === void 0\n              ? void 0\n              : _node$interfaces.map(getNamedType)) !== null &&\n            _node$interfaces$map !== void 0\n            ? _node$interfaces$map\n            : []\n        );\n      },\n    );\n  }\n\n  function buildUnionTypes(nodes) {\n    // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    // @ts-expect-error\n    return nodes.flatMap(\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      (node) => {\n        var _node$types$map, _node$types;\n\n        return (\n          /* c8 ignore next */\n          (_node$types$map =\n            (_node$types = node.types) === null || _node$types === void 0\n              ? void 0\n              : _node$types.map(getNamedType)) !== null &&\n            _node$types$map !== void 0\n            ? _node$types$map\n            : []\n        );\n      },\n    );\n  }\n\n  function buildType(astNode) {\n    var _typeExtensionsMap$na;\n\n    const name = astNode.name.value;\n    const extensionASTNodes =\n      (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null &&\n      _typeExtensionsMap$na !== void 0\n        ? _typeExtensionsMap$na\n        : [];\n\n    switch (astNode.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION: {\n        var _astNode$description;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new GraphQLObjectType({\n          name,\n          description:\n            (_astNode$description = astNode.description) === null ||\n            _astNode$description === void 0\n              ? void 0\n              : _astNode$description.value,\n          interfaces: () => buildInterfaces(allNodes),\n          fields: () => buildFieldMap(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case Kind.INTERFACE_TYPE_DEFINITION: {\n        var _astNode$description2;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new GraphQLInterfaceType({\n          name,\n          description:\n            (_astNode$description2 = astNode.description) === null ||\n            _astNode$description2 === void 0\n              ? void 0\n              : _astNode$description2.value,\n          interfaces: () => buildInterfaces(allNodes),\n          fields: () => buildFieldMap(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case Kind.ENUM_TYPE_DEFINITION: {\n        var _astNode$description3;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new GraphQLEnumType({\n          name,\n          description:\n            (_astNode$description3 = astNode.description) === null ||\n            _astNode$description3 === void 0\n              ? void 0\n              : _astNode$description3.value,\n          values: buildEnumValueMap(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case Kind.UNION_TYPE_DEFINITION: {\n        var _astNode$description4;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new GraphQLUnionType({\n          name,\n          description:\n            (_astNode$description4 = astNode.description) === null ||\n            _astNode$description4 === void 0\n              ? void 0\n              : _astNode$description4.value,\n          types: () => buildUnionTypes(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case Kind.SCALAR_TYPE_DEFINITION: {\n        var _astNode$description5;\n\n        return new GraphQLScalarType({\n          name,\n          description:\n            (_astNode$description5 = astNode.description) === null ||\n            _astNode$description5 === void 0\n              ? void 0\n              : _astNode$description5.value,\n          specifiedByURL: getSpecifiedByURL(astNode),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION: {\n        var _astNode$description6;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new GraphQLInputObjectType({\n          name,\n          description:\n            (_astNode$description6 = astNode.description) === null ||\n            _astNode$description6 === void 0\n              ? void 0\n              : _astNode$description6.value,\n          fields: () => buildInputFieldMap(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n    }\n  }\n}\nconst stdTypeMap = keyMap(\n  [...specifiedScalarTypes, ...introspectionTypes],\n  (type) => type.name,\n);\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\nfunction getDeprecationReason(node) {\n  const deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node); // @ts-expect-error validated by `getDirectiveValues`\n\n  return deprecated === null || deprecated === void 0\n    ? void 0\n    : deprecated.reason;\n}\n/**\n * Given a scalar node, returns the string value for the specifiedByURL.\n */\n\nfunction getSpecifiedByURL(node) {\n  const specifiedBy = getDirectiveValues(GraphQLSpecifiedByDirective, node); // @ts-expect-error validated by `getDirectiveValues`\n\n  return specifiedBy === null || specifiedBy === void 0\n    ? void 0\n    : specifiedBy.url;\n}\n", "import { devAssert } from '../jsutils/devAssert.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { parse } from '../language/parser.mjs';\nimport { specifiedDirectives } from '../type/directives.mjs';\nimport { GraphQLSchema } from '../type/schema.mjs';\nimport { assertValidSDL } from '../validation/validate.mjs';\nimport { extendSchemaImpl } from './extendSchema.mjs';\n\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query,\n * Mutation and Subscription.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n */\nexport function buildASTSchema(documentAST, options) {\n  (documentAST != null && documentAST.kind === Kind.DOCUMENT) ||\n    devAssert(false, 'Must provide valid Document AST.');\n\n  if (\n    (options === null || options === void 0 ? void 0 : options.assumeValid) !==\n      true &&\n    (options === null || options === void 0\n      ? void 0\n      : options.assumeValidSDL) !== true\n  ) {\n    assertValidSDL(documentAST);\n  }\n\n  const emptySchemaConfig = {\n    description: undefined,\n    types: [],\n    directives: [],\n    extensions: Object.create(null),\n    extensionASTNodes: [],\n    assumeValid: false,\n  };\n  const config = extendSchemaImpl(emptySchemaConfig, documentAST, options);\n\n  if (config.astNode == null) {\n    for (const type of config.types) {\n      switch (type.name) {\n        // Note: While this could make early assertions to get the correctly\n        // typed values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n        case 'Query':\n          // @ts-expect-error validated in `validateSchema`\n          config.query = type;\n          break;\n\n        case 'Mutation':\n          // @ts-expect-error validated in `validateSchema`\n          config.mutation = type;\n          break;\n\n        case 'Subscription':\n          // @ts-expect-error validated in `validateSchema`\n          config.subscription = type;\n          break;\n      }\n    }\n  }\n\n  const directives = [\n    ...config.directives, // If specified directives were not explicitly declared, add them.\n    ...specifiedDirectives.filter((stdDirective) =>\n      config.directives.every(\n        (directive) => directive.name !== stdDirective.name,\n      ),\n    ),\n  ];\n  return new GraphQLSchema({ ...config, directives });\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\nexport function buildSchema(source, options) {\n  const document = parse(source, {\n    noLocation:\n      options === null || options === void 0 ? void 0 : options.noLocation,\n    allowLegacyFragmentVariables:\n      options === null || options === void 0\n        ? void 0\n        : options.allowLegacyFragmentVariables,\n  });\n  return buildASTSchema(document, {\n    assumeValidSDL:\n      options === null || options === void 0 ? void 0 : options.assumeValidSDL,\n    assumeValid:\n      options === null || options === void 0 ? void 0 : options.assumeValid,\n  });\n}\n", "import { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { keyValMap } from '../jsutils/keyValMap.mjs';\nimport { naturalCompare } from '../jsutils/naturalCompare.mjs';\nimport {\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLUnionType,\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n} from '../type/definition.mjs';\nimport { GraphQLDirective } from '../type/directives.mjs';\nimport { isIntrospectionType } from '../type/introspection.mjs';\nimport { GraphQLSchema } from '../type/schema.mjs';\n/**\n * Sort GraphQLSchema.\n *\n * This function returns a sorted copy of the given GraphQLSchema.\n */\n\nexport function lexicographicSortSchema(schema) {\n  const schemaConfig = schema.toConfig();\n  const typeMap = keyValMap(\n    sortByName(schemaConfig.types),\n    (type) => type.name,\n    sortNamedType,\n  );\n  return new GraphQLSchema({\n    ...schemaConfig,\n    types: Object.values(typeMap),\n    directives: sortByName(schemaConfig.directives).map(sortDirective),\n    query: replaceMaybeType(schemaConfig.query),\n    mutation: replaceMaybeType(schemaConfig.mutation),\n    subscription: replaceMaybeType(schemaConfig.subscription),\n  });\n\n  function replaceType(type) {\n    if (isListType(type)) {\n      // @ts-expect-error\n      return new GraphQLList(replaceType(type.ofType));\n    } else if (isNonNullType(type)) {\n      // @ts-expect-error\n      return new GraphQLNonNull(replaceType(type.ofType));\n    } // @ts-expect-error FIXME: TS Conversion\n\n    return replaceNamedType(type);\n  }\n\n  function replaceNamedType(type) {\n    return typeMap[type.name];\n  }\n\n  function replaceMaybeType(maybeType) {\n    return maybeType && replaceNamedType(maybeType);\n  }\n\n  function sortDirective(directive) {\n    const config = directive.toConfig();\n    return new GraphQLDirective({\n      ...config,\n      locations: sortBy(config.locations, (x) => x),\n      args: sortArgs(config.args),\n    });\n  }\n\n  function sortArgs(args) {\n    return sortObjMap(args, (arg) => ({ ...arg, type: replaceType(arg.type) }));\n  }\n\n  function sortFields(fieldsMap) {\n    return sortObjMap(fieldsMap, (field) => ({\n      ...field,\n      type: replaceType(field.type),\n      args: field.args && sortArgs(field.args),\n    }));\n  }\n\n  function sortInputFields(fieldsMap) {\n    return sortObjMap(fieldsMap, (field) => ({\n      ...field,\n      type: replaceType(field.type),\n    }));\n  }\n\n  function sortTypes(array) {\n    return sortByName(array).map(replaceNamedType);\n  }\n\n  function sortNamedType(type) {\n    if (isScalarType(type) || isIntrospectionType(type)) {\n      return type;\n    }\n\n    if (isObjectType(type)) {\n      const config = type.toConfig();\n      return new GraphQLObjectType({\n        ...config,\n        interfaces: () => sortTypes(config.interfaces),\n        fields: () => sortFields(config.fields),\n      });\n    }\n\n    if (isInterfaceType(type)) {\n      const config = type.toConfig();\n      return new GraphQLInterfaceType({\n        ...config,\n        interfaces: () => sortTypes(config.interfaces),\n        fields: () => sortFields(config.fields),\n      });\n    }\n\n    if (isUnionType(type)) {\n      const config = type.toConfig();\n      return new GraphQLUnionType({\n        ...config,\n        types: () => sortTypes(config.types),\n      });\n    }\n\n    if (isEnumType(type)) {\n      const config = type.toConfig();\n      return new GraphQLEnumType({\n        ...config,\n        values: sortObjMap(config.values, (value) => value),\n      });\n    }\n\n    if (isInputObjectType(type)) {\n      const config = type.toConfig();\n      return new GraphQLInputObjectType({\n        ...config,\n        fields: () => sortInputFields(config.fields),\n      });\n    }\n    /* c8 ignore next 3 */\n    // Not reachable, all possible types have been considered.\n\n    false || invariant(false, 'Unexpected type: ' + inspect(type));\n  }\n}\n\nfunction sortObjMap(map, sortValueFn) {\n  const sortedMap = Object.create(null);\n\n  for (const key of Object.keys(map).sort(naturalCompare)) {\n    sortedMap[key] = sortValueFn(map[key]);\n  }\n\n  return sortedMap;\n}\n\nfunction sortByName(array) {\n  return sortBy(array, (obj) => obj.name);\n}\n\nfunction sortBy(array, mapToKey) {\n  return array.slice().sort((obj1, obj2) => {\n    const key1 = mapToKey(obj1);\n    const key2 = mapToKey(obj2);\n    return naturalCompare(key1, key2);\n  });\n}\n", "import { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { isPrintableAsBlockString } from '../language/blockString.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { print } from '../language/printer.mjs';\nimport {\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n} from '../type/definition.mjs';\nimport {\n  DEFAULT_DEPRECATION_REASON,\n  isSpecifiedDirective,\n} from '../type/directives.mjs';\nimport { isIntrospectionType } from '../type/introspection.mjs';\nimport { isSpecifiedScalarType } from '../type/scalars.mjs';\nimport { astFromValue } from './astFromValue.mjs';\nexport function printSchema(schema) {\n  return printFilteredSchema(\n    schema,\n    (n) => !isSpecifiedDirective(n),\n    isDefinedType,\n  );\n}\nexport function printIntrospectionSchema(schema) {\n  return printFilteredSchema(schema, isSpecifiedDirective, isIntrospectionType);\n}\n\nfunction isDefinedType(type) {\n  return !isSpecifiedScalarType(type) && !isIntrospectionType(type);\n}\n\nfunction printFilteredSchema(schema, directiveFilter, typeFilter) {\n  const directives = schema.getDirectives().filter(directiveFilter);\n  const types = Object.values(schema.getTypeMap()).filter(typeFilter);\n  return [\n    printSchemaDefinition(schema),\n    ...directives.map((directive) => printDirective(directive)),\n    ...types.map((type) => printType(type)),\n  ]\n    .filter(Boolean)\n    .join('\\n\\n');\n}\n\nfunction printSchemaDefinition(schema) {\n  if (schema.description == null && isSchemaOfCommonNames(schema)) {\n    return;\n  }\n\n  const operationTypes = [];\n  const queryType = schema.getQueryType();\n\n  if (queryType) {\n    operationTypes.push(`  query: ${queryType.name}`);\n  }\n\n  const mutationType = schema.getMutationType();\n\n  if (mutationType) {\n    operationTypes.push(`  mutation: ${mutationType.name}`);\n  }\n\n  const subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType) {\n    operationTypes.push(`  subscription: ${subscriptionType.name}`);\n  }\n\n  return printDescription(schema) + `schema {\\n${operationTypes.join('\\n')}\\n}`;\n}\n/**\n * GraphQL schema define root types for each type of operation. These types are\n * the same as any other type and can be named in any manner, however there is\n * a common naming convention:\n *\n * ```graphql\n *   schema {\n *     query: Query\n *     mutation: Mutation\n *     subscription: Subscription\n *   }\n * ```\n *\n * When using this naming convention, the schema description can be omitted.\n */\n\nfunction isSchemaOfCommonNames(schema) {\n  const queryType = schema.getQueryType();\n\n  if (queryType && queryType.name !== 'Query') {\n    return false;\n  }\n\n  const mutationType = schema.getMutationType();\n\n  if (mutationType && mutationType.name !== 'Mutation') {\n    return false;\n  }\n\n  const subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && subscriptionType.name !== 'Subscription') {\n    return false;\n  }\n\n  return true;\n}\n\nexport function printType(type) {\n  if (isScalarType(type)) {\n    return printScalar(type);\n  }\n\n  if (isObjectType(type)) {\n    return printObject(type);\n  }\n\n  if (isInterfaceType(type)) {\n    return printInterface(type);\n  }\n\n  if (isUnionType(type)) {\n    return printUnion(type);\n  }\n\n  if (isEnumType(type)) {\n    return printEnum(type);\n  }\n\n  if (isInputObjectType(type)) {\n    return printInputObject(type);\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n  false || invariant(false, 'Unexpected type: ' + inspect(type));\n}\n\nfunction printScalar(type) {\n  return (\n    printDescription(type) + `scalar ${type.name}` + printSpecifiedByURL(type)\n  );\n}\n\nfunction printImplementedInterfaces(type) {\n  const interfaces = type.getInterfaces();\n  return interfaces.length\n    ? ' implements ' + interfaces.map((i) => i.name).join(' & ')\n    : '';\n}\n\nfunction printObject(type) {\n  return (\n    printDescription(type) +\n    `type ${type.name}` +\n    printImplementedInterfaces(type) +\n    printFields(type)\n  );\n}\n\nfunction printInterface(type) {\n  return (\n    printDescription(type) +\n    `interface ${type.name}` +\n    printImplementedInterfaces(type) +\n    printFields(type)\n  );\n}\n\nfunction printUnion(type) {\n  const types = type.getTypes();\n  const possibleTypes = types.length ? ' = ' + types.join(' | ') : '';\n  return printDescription(type) + 'union ' + type.name + possibleTypes;\n}\n\nfunction printEnum(type) {\n  const values = type\n    .getValues()\n    .map(\n      (value, i) =>\n        printDescription(value, '  ', !i) +\n        '  ' +\n        value.name +\n        printDeprecated(value.deprecationReason),\n    );\n  return printDescription(type) + `enum ${type.name}` + printBlock(values);\n}\n\nfunction printInputObject(type) {\n  const fields = Object.values(type.getFields()).map(\n    (f, i) => printDescription(f, '  ', !i) + '  ' + printInputValue(f),\n  );\n  return printDescription(type) + `input ${type.name}` + printBlock(fields);\n}\n\nfunction printFields(type) {\n  const fields = Object.values(type.getFields()).map(\n    (f, i) =>\n      printDescription(f, '  ', !i) +\n      '  ' +\n      f.name +\n      printArgs(f.args, '  ') +\n      ': ' +\n      String(f.type) +\n      printDeprecated(f.deprecationReason),\n  );\n  return printBlock(fields);\n}\n\nfunction printBlock(items) {\n  return items.length !== 0 ? ' {\\n' + items.join('\\n') + '\\n}' : '';\n}\n\nfunction printArgs(args, indentation = '') {\n  if (args.length === 0) {\n    return '';\n  } // If every arg does not have a description, print them on one line.\n\n  if (args.every((arg) => !arg.description)) {\n    return '(' + args.map(printInputValue).join(', ') + ')';\n  }\n\n  return (\n    '(\\n' +\n    args\n      .map(\n        (arg, i) =>\n          printDescription(arg, '  ' + indentation, !i) +\n          '  ' +\n          indentation +\n          printInputValue(arg),\n      )\n      .join('\\n') +\n    '\\n' +\n    indentation +\n    ')'\n  );\n}\n\nfunction printInputValue(arg) {\n  const defaultAST = astFromValue(arg.defaultValue, arg.type);\n  let argDecl = arg.name + ': ' + String(arg.type);\n\n  if (defaultAST) {\n    argDecl += ` = ${print(defaultAST)}`;\n  }\n\n  return argDecl + printDeprecated(arg.deprecationReason);\n}\n\nfunction printDirective(directive) {\n  return (\n    printDescription(directive) +\n    'directive @' +\n    directive.name +\n    printArgs(directive.args) +\n    (directive.isRepeatable ? ' repeatable' : '') +\n    ' on ' +\n    directive.locations.join(' | ')\n  );\n}\n\nfunction printDeprecated(reason) {\n  if (reason == null) {\n    return '';\n  }\n\n  if (reason !== DEFAULT_DEPRECATION_REASON) {\n    const astValue = print({\n      kind: Kind.STRING,\n      value: reason,\n    });\n    return ` @deprecated(reason: ${astValue})`;\n  }\n\n  return ' @deprecated';\n}\n\nfunction printSpecifiedByURL(scalar) {\n  if (scalar.specifiedByURL == null) {\n    return '';\n  }\n\n  const astValue = print({\n    kind: Kind.STRING,\n    value: scalar.specifiedByURL,\n  });\n  return ` @specifiedBy(url: ${astValue})`;\n}\n\nfunction printDescription(def, indentation = '', firstInBlock = true) {\n  const { description } = def;\n\n  if (description == null) {\n    return '';\n  }\n\n  const blockString = print({\n    kind: Kind.STRING,\n    value: description,\n    block: isPrintableAsBlockString(description),\n  });\n  const prefix =\n    indentation && !firstInBlock ? '\\n' + indentation : indentation;\n  return prefix + blockString.replace(/\\n/g, '\\n' + indentation) + '\\n';\n}\n", "import { Kind } from '../language/kinds.mjs';\n/**\n * Provided a collection of ASTs, presumably each from different files,\n * concatenate the ASTs together into batched AST, useful for validating many\n * GraphQL source files which together represent one conceptual application.\n */\n\nexport function concatAST(documents) {\n  const definitions = [];\n\n  for (const doc of documents) {\n    definitions.push(...doc.definitions);\n  }\n\n  return {\n    kind: Kind.DOCUMENT,\n    definitions,\n  };\n}\n", "import { Kind } from '../language/kinds.mjs';\nimport { visit } from '../language/visitor.mjs';\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\n\nexport function separateOperations(documentAST) {\n  const operations = [];\n  const depGraph = Object.create(null); // Populate metadata and build a dependency graph.\n\n  for (const definitionNode of documentAST.definitions) {\n    switch (definitionNode.kind) {\n      case Kind.OPERATION_DEFINITION:\n        operations.push(definitionNode);\n        break;\n\n      case Kind.FRAGMENT_DEFINITION:\n        depGraph[definitionNode.name.value] = collectDependencies(\n          definitionNode.selectionSet,\n        );\n        break;\n\n      default: // ignore non-executable definitions\n    }\n  } // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n\n  const separatedDocumentASTs = Object.create(null);\n\n  for (const operation of operations) {\n    const dependencies = new Set();\n\n    for (const fragmentName of collectDependencies(operation.selectionSet)) {\n      collectTransitiveDependencies(dependencies, depGraph, fragmentName);\n    } // Provides the empty string for anonymous operations.\n\n    const operationName = operation.name ? operation.name.value : ''; // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    separatedDocumentASTs[operationName] = {\n      kind: Kind.DOCUMENT,\n      definitions: documentAST.definitions.filter(\n        (node) =>\n          node === operation ||\n          (node.kind === Kind.FRAGMENT_DEFINITION &&\n            dependencies.has(node.name.value)),\n      ),\n    };\n  }\n\n  return separatedDocumentASTs;\n}\n\n// From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  if (!collected.has(fromName)) {\n    collected.add(fromName);\n    const immediateDeps = depGraph[fromName];\n\n    if (immediateDeps !== undefined) {\n      for (const toName of immediateDeps) {\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}\n\nfunction collectDependencies(selectionSet) {\n  const dependencies = [];\n  visit(selectionSet, {\n    FragmentSpread(node) {\n      dependencies.push(node.name.value);\n    },\n  });\n  return dependencies;\n}\n", "import { printBlockString } from '../language/blockString.mjs';\nimport { isPunctuatorTokenKind, Lexer } from '../language/lexer.mjs';\nimport { isSource, Source } from '../language/source.mjs';\nimport { TokenKind } from '../language/tokenKind.mjs';\n/**\n * Strips characters that are not significant to the validity or execution\n * of a GraphQL document:\n *   - UnicodeBOM\n *   - WhiteSpace\n *   - LineTerminator\n *   - Comment\n *   - Comma\n *   - BlockString indentation\n *\n * Note: It is required to have a delimiter character between neighboring\n * non-punctuator tokens and this function always uses single space as delimiter.\n *\n * It is guaranteed that both input and output documents if parsed would result\n * in the exact same AST except for nodes location.\n *\n * Warning: It is guaranteed that this function will always produce stable results.\n * However, it's not guaranteed that it will stay the same between different\n * releases due to bugfixes or changes in the GraphQL specification.\n *\n * Query example:\n *\n * ```graphql\n * query SomeQuery($foo: String!, $bar: String) {\n *   someField(foo: $foo, bar: $bar) {\n *     a\n *     b {\n *       c\n *       d\n *     }\n *   }\n * }\n * ```\n *\n * Becomes:\n *\n * ```graphql\n * query SomeQuery($foo:String!$bar:String){someField(foo:$foo bar:$bar){a b{c d}}}\n * ```\n *\n * SDL example:\n *\n * ```graphql\n * \"\"\"\n * Type description\n * \"\"\"\n * type Foo {\n *   \"\"\"\n *   Field description\n *   \"\"\"\n *   bar: String\n * }\n * ```\n *\n * Becomes:\n *\n * ```graphql\n * \"\"\"Type description\"\"\" type Foo{\"\"\"Field description\"\"\" bar:String}\n * ```\n */\n\nexport function stripIgnoredCharacters(source) {\n  const sourceObj = isSource(source) ? source : new Source(source);\n  const body = sourceObj.body;\n  const lexer = new Lexer(sourceObj);\n  let strippedBody = '';\n  let wasLastAddedTokenNonPunctuator = false;\n\n  while (lexer.advance().kind !== TokenKind.EOF) {\n    const currentToken = lexer.token;\n    const tokenKind = currentToken.kind;\n    /**\n     * Every two non-punctuator tokens should have space between them.\n     * Also prevent case of non-punctuator token following by spread resulting\n     * in invalid token (e.g. `1...` is invalid Float token).\n     */\n\n    const isNonPunctuator = !isPunctuatorTokenKind(currentToken.kind);\n\n    if (wasLastAddedTokenNonPunctuator) {\n      if (isNonPunctuator || currentToken.kind === TokenKind.SPREAD) {\n        strippedBody += ' ';\n      }\n    }\n\n    const tokenBody = body.slice(currentToken.start, currentToken.end);\n\n    if (tokenKind === TokenKind.BLOCK_STRING) {\n      strippedBody += printBlockString(currentToken.value, {\n        minimize: true,\n      });\n    } else {\n      strippedBody += tokenBody;\n    }\n\n    wasLastAddedTokenNonPunctuator = isNonPunctuator;\n  }\n\n  return strippedBody;\n}\n", "import { devAssert } from '../jsutils/devAssert.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { assertName } from '../type/assertName.mjs';\n/* c8 ignore start */\n\n/**\n * Upholds the spec rules about naming.\n * @deprecated Please use `assertName` instead. Will be removed in v17\n */\n\nexport function assertValidName(name) {\n  const error = isValidNameError(name);\n\n  if (error) {\n    throw error;\n  }\n\n  return name;\n}\n/**\n * Returns an Error if a name is invalid.\n * @deprecated Please use `assertName` instead. Will be removed in v17\n */\n\nexport function isValidNameError(name) {\n  typeof name === 'string' || devAssert(false, 'Expected name to be a string.');\n\n  if (name.startsWith('__')) {\n    return new GraphQLError(\n      `Name \"${name}\" must not begin with \"__\", which is reserved by GraphQL introspection.`,\n    );\n  }\n\n  try {\n    assertName(name);\n  } catch (error) {\n    return error;\n  }\n}\n/* c8 ignore stop */\n", "import { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { keyMap } from '../jsutils/keyMap.mjs';\nimport { print } from '../language/printer.mjs';\nimport {\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isListType,\n  isNamedType,\n  isNonNullType,\n  isObjectType,\n  isRequiredArgument,\n  isRequiredInputField,\n  isScalarType,\n  isUnionType,\n} from '../type/definition.mjs';\nimport { isSpecifiedScalarType } from '../type/scalars.mjs';\nimport { astFromValue } from './astFromValue.mjs';\nimport { sortValueNode } from './sortValueNode.mjs';\nvar BreakingChangeType;\n\n(function (BreakingChangeType) {\n  BreakingChangeType['TYPE_REMOVED'] = 'TYPE_REMOVED';\n  BreakingChangeType['TYPE_CHANGED_KIND'] = 'TYPE_CHANGED_KIND';\n  BreakingChangeType['TYPE_REMOVED_FROM_UNION'] = 'TYPE_REMOVED_FROM_UNION';\n  BreakingChangeType['VALUE_REMOVED_FROM_ENUM'] = 'VALUE_REMOVED_FROM_ENUM';\n  BreakingChangeType['REQUIRED_INPUT_FIELD_ADDED'] =\n    'REQUIRED_INPUT_FIELD_ADDED';\n  BreakingChangeType['IMPLEMENTED_INTERFACE_REMOVED'] =\n    'IMPLEMENTED_INTERFACE_REMOVED';\n  BreakingChangeType['FIELD_REMOVED'] = 'FIELD_REMOVED';\n  BreakingChangeType['FIELD_CHANGED_KIND'] = 'FIELD_CHANGED_KIND';\n  BreakingChangeType['REQUIRED_ARG_ADDED'] = 'REQUIRED_ARG_ADDED';\n  BreakingChangeType['ARG_REMOVED'] = 'ARG_REMOVED';\n  BreakingChangeType['ARG_CHANGED_KIND'] = 'ARG_CHANGED_KIND';\n  BreakingChangeType['DIRECTIVE_REMOVED'] = 'DIRECTIVE_REMOVED';\n  BreakingChangeType['DIRECTIVE_ARG_REMOVED'] = 'DIRECTIVE_ARG_REMOVED';\n  BreakingChangeType['REQUIRED_DIRECTIVE_ARG_ADDED'] =\n    'REQUIRED_DIRECTIVE_ARG_ADDED';\n  BreakingChangeType['DIRECTIVE_REPEATABLE_REMOVED'] =\n    'DIRECTIVE_REPEATABLE_REMOVED';\n  BreakingChangeType['DIRECTIVE_LOCATION_REMOVED'] =\n    'DIRECTIVE_LOCATION_REMOVED';\n})(BreakingChangeType || (BreakingChangeType = {}));\n\nexport { BreakingChangeType };\nvar DangerousChangeType;\n\n(function (DangerousChangeType) {\n  DangerousChangeType['VALUE_ADDED_TO_ENUM'] = 'VALUE_ADDED_TO_ENUM';\n  DangerousChangeType['TYPE_ADDED_TO_UNION'] = 'TYPE_ADDED_TO_UNION';\n  DangerousChangeType['OPTIONAL_INPUT_FIELD_ADDED'] =\n    'OPTIONAL_INPUT_FIELD_ADDED';\n  DangerousChangeType['OPTIONAL_ARG_ADDED'] = 'OPTIONAL_ARG_ADDED';\n  DangerousChangeType['IMPLEMENTED_INTERFACE_ADDED'] =\n    'IMPLEMENTED_INTERFACE_ADDED';\n  DangerousChangeType['ARG_DEFAULT_VALUE_CHANGE'] = 'ARG_DEFAULT_VALUE_CHANGE';\n})(DangerousChangeType || (DangerousChangeType = {}));\n\nexport { DangerousChangeType };\n\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of breaking changes covered by the other functions down below.\n */\nexport function findBreakingChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(\n    (change) => change.type in BreakingChangeType,\n  );\n}\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of potentially dangerous changes covered by the other functions down below.\n */\n\nexport function findDangerousChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(\n    (change) => change.type in DangerousChangeType,\n  );\n}\n\nfunction findSchemaChanges(oldSchema, newSchema) {\n  return [\n    ...findTypeChanges(oldSchema, newSchema),\n    ...findDirectiveChanges(oldSchema, newSchema),\n  ];\n}\n\nfunction findDirectiveChanges(oldSchema, newSchema) {\n  const schemaChanges = [];\n  const directivesDiff = diff(\n    oldSchema.getDirectives(),\n    newSchema.getDirectives(),\n  );\n\n  for (const oldDirective of directivesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.DIRECTIVE_REMOVED,\n      description: `${oldDirective.name} was removed.`,\n    });\n  }\n\n  for (const [oldDirective, newDirective] of directivesDiff.persisted) {\n    const argsDiff = diff(oldDirective.args, newDirective.args);\n\n    for (const newArg of argsDiff.added) {\n      if (isRequiredArgument(newArg)) {\n        schemaChanges.push({\n          type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,\n          description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`,\n        });\n      }\n    }\n\n    for (const oldArg of argsDiff.removed) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,\n        description: `${oldArg.name} was removed from ${oldDirective.name}.`,\n      });\n    }\n\n    if (oldDirective.isRepeatable && !newDirective.isRepeatable) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,\n        description: `Repeatable flag was removed from ${oldDirective.name}.`,\n      });\n    }\n\n    for (const location of oldDirective.locations) {\n      if (!newDirective.locations.includes(location)) {\n        schemaChanges.push({\n          type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,\n          description: `${location} was removed from ${oldDirective.name}.`,\n        });\n      }\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findTypeChanges(oldSchema, newSchema) {\n  const schemaChanges = [];\n  const typesDiff = diff(\n    Object.values(oldSchema.getTypeMap()),\n    Object.values(newSchema.getTypeMap()),\n  );\n\n  for (const oldType of typesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED,\n      description: isSpecifiedScalarType(oldType)\n        ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.`\n        : `${oldType.name} was removed.`,\n    });\n  }\n\n  for (const [oldType, newType] of typesDiff.persisted) {\n    if (isEnumType(oldType) && isEnumType(newType)) {\n      schemaChanges.push(...findEnumTypeChanges(oldType, newType));\n    } else if (isUnionType(oldType) && isUnionType(newType)) {\n      schemaChanges.push(...findUnionTypeChanges(oldType, newType));\n    } else if (isInputObjectType(oldType) && isInputObjectType(newType)) {\n      schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));\n    } else if (isObjectType(oldType) && isObjectType(newType)) {\n      schemaChanges.push(\n        ...findFieldChanges(oldType, newType),\n        ...findImplementedInterfacesChanges(oldType, newType),\n      );\n    } else if (isInterfaceType(oldType) && isInterfaceType(newType)) {\n      schemaChanges.push(\n        ...findFieldChanges(oldType, newType),\n        ...findImplementedInterfacesChanges(oldType, newType),\n      );\n    } else if (oldType.constructor !== newType.constructor) {\n      schemaChanges.push({\n        type: BreakingChangeType.TYPE_CHANGED_KIND,\n        description:\n          `${oldType.name} changed from ` +\n          `${typeKindName(oldType)} to ${typeKindName(newType)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findInputObjectTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const fieldsDiff = diff(\n    Object.values(oldType.getFields()),\n    Object.values(newType.getFields()),\n  );\n\n  for (const newField of fieldsDiff.added) {\n    if (isRequiredInputField(newField)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,\n        description: `A required field ${newField.name} on input type ${oldType.name} was added.`,\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,\n        description: `An optional field ${newField.name} on input type ${oldType.name} was added.`,\n      });\n    }\n  }\n\n  for (const oldField of fieldsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: `${oldType.name}.${oldField.name} was removed.`,\n    });\n  }\n\n  for (const [oldField, newField] of fieldsDiff.persisted) {\n    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(\n      oldField.type,\n      newField.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} changed type from ` +\n          `${String(oldField.type)} to ${String(newField.type)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findUnionTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());\n\n  for (const newPossibleType of possibleTypesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.TYPE_ADDED_TO_UNION,\n      description: `${newPossibleType.name} was added to union type ${oldType.name}.`,\n    });\n  }\n\n  for (const oldPossibleType of possibleTypesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n      description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findEnumTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const valuesDiff = diff(oldType.getValues(), newType.getValues());\n\n  for (const newValue of valuesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.VALUE_ADDED_TO_ENUM,\n      description: `${newValue.name} was added to enum type ${oldType.name}.`,\n    });\n  }\n\n  for (const oldValue of valuesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n      description: `${oldValue.name} was removed from enum type ${oldType.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findImplementedInterfacesChanges(oldType, newType) {\n  const schemaChanges = [];\n  const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());\n\n  for (const newInterface of interfacesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,\n      description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`,\n    });\n  }\n\n  for (const oldInterface of interfacesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,\n      description: `${oldType.name} no longer implements interface ${oldInterface.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findFieldChanges(oldType, newType) {\n  const schemaChanges = [];\n  const fieldsDiff = diff(\n    Object.values(oldType.getFields()),\n    Object.values(newType.getFields()),\n  );\n\n  for (const oldField of fieldsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: `${oldType.name}.${oldField.name} was removed.`,\n    });\n  }\n\n  for (const [oldField, newField] of fieldsDiff.persisted) {\n    schemaChanges.push(...findArgChanges(oldType, oldField, newField));\n    const isSafe = isChangeSafeForObjectOrInterfaceField(\n      oldField.type,\n      newField.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} changed type from ` +\n          `${String(oldField.type)} to ${String(newField.type)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findArgChanges(oldType, oldField, newField) {\n  const schemaChanges = [];\n  const argsDiff = diff(oldField.args, newField.args);\n\n  for (const oldArg of argsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.ARG_REMOVED,\n      description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`,\n    });\n  }\n\n  for (const [oldArg, newArg] of argsDiff.persisted) {\n    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(\n      oldArg.type,\n      newArg.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.ARG_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ` +\n          `${String(oldArg.type)} to ${String(newArg.type)}.`,\n      });\n    } else if (oldArg.defaultValue !== undefined) {\n      if (newArg.defaultValue === undefined) {\n        schemaChanges.push({\n          type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n          description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`,\n        });\n      } else {\n        // Since we looking only for client's observable changes we should\n        // compare default values in the same representation as they are\n        // represented inside introspection.\n        const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);\n        const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);\n\n        if (oldValueStr !== newValueStr) {\n          schemaChanges.push({\n            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`,\n          });\n        }\n      }\n    }\n  }\n\n  for (const newArg of argsDiff.added) {\n    if (isRequiredArgument(newArg)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_ARG_ADDED,\n        description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`,\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_ARG_ADDED,\n        description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction isChangeSafeForObjectOrInterfaceField(oldType, newType) {\n  if (isListType(oldType)) {\n    return (\n      // if they're both lists, make sure the underlying types are compatible\n      (isListType(newType) &&\n        isChangeSafeForObjectOrInterfaceField(\n          oldType.ofType,\n          newType.ofType,\n        )) || // moving from nullable to non-null of the same underlying type is safe\n      (isNonNullType(newType) &&\n        isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType))\n    );\n  }\n\n  if (isNonNullType(oldType)) {\n    // if they're both non-null, make sure the underlying types are compatible\n    return (\n      isNonNullType(newType) &&\n      isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType)\n    );\n  }\n\n  return (\n    // if they're both named types, see if their names are equivalent\n    (isNamedType(newType) && oldType.name === newType.name) || // moving from nullable to non-null of the same underlying type is safe\n    (isNonNullType(newType) &&\n      isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType))\n  );\n}\n\nfunction isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {\n  if (isListType(oldType)) {\n    // if they're both lists, make sure the underlying types are compatible\n    return (\n      isListType(newType) &&\n      isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType)\n    );\n  }\n\n  if (isNonNullType(oldType)) {\n    return (\n      // if they're both non-null, make sure the underlying types are\n      // compatible\n      (isNonNullType(newType) &&\n        isChangeSafeForInputObjectFieldOrFieldArg(\n          oldType.ofType,\n          newType.ofType,\n        )) || // moving from non-null to nullable of the same underlying type is safe\n      (!isNonNullType(newType) &&\n        isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType))\n    );\n  } // if they're both named types, see if their names are equivalent\n\n  return isNamedType(newType) && oldType.name === newType.name;\n}\n\nfunction typeKindName(type) {\n  if (isScalarType(type)) {\n    return 'a Scalar type';\n  }\n\n  if (isObjectType(type)) {\n    return 'an Object type';\n  }\n\n  if (isInterfaceType(type)) {\n    return 'an Interface type';\n  }\n\n  if (isUnionType(type)) {\n    return 'a Union type';\n  }\n\n  if (isEnumType(type)) {\n    return 'an Enum type';\n  }\n\n  if (isInputObjectType(type)) {\n    return 'an Input type';\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n  false || invariant(false, 'Unexpected type: ' + inspect(type));\n}\n\nfunction stringifyValue(value, type) {\n  const ast = astFromValue(value, type);\n  ast != null || invariant(false);\n  return print(sortValueNode(ast));\n}\n\nfunction diff(oldArray, newArray) {\n  const added = [];\n  const removed = [];\n  const persisted = [];\n  const oldMap = keyMap(oldArray, ({ name }) => name);\n  const newMap = keyMap(newArray, ({ name }) => name);\n\n  for (const oldItem of oldArray) {\n    const newItem = newMap[oldItem.name];\n\n    if (newItem === undefined) {\n      removed.push(oldItem);\n    } else {\n      persisted.push([oldItem, newItem]);\n    }\n  }\n\n  for (const newItem of newArray) {\n    if (oldMap[newItem.name] === undefined) {\n      added.push(newItem);\n    }\n  }\n\n  return {\n    added,\n    persisted,\n    removed,\n  };\n}\n"],
  "mappings": "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",
  "names": ["getNamedType", "getNamedType", "BreakingChangeType", "DangerousChangeType"]
}
